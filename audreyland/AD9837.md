Great, I’ll walk through how to control the AD9837 from an Adafruit RP2040 using Arduino C. This will include sending SPI commands to produce an initial DC voltage (via 0 Hz frequency), then transitioning to a sine wave at a defined frequency. I’ll find specific register commands, wiring tips, and Arduino code examples tailored for your setup.

I’ll get back to you shortly with a full guide.

# Controlling the AD9837 Waveform Generator with an RP2040 (Arduino)

## Introduction

In this tutorial, we’ll learn how to interface an **Analog Devices AD9837** low-power programmable waveform generator with an **Adafruit RP2040-based microcontroller** (running Arduino) over SPI. We will cover how to initialize the AD9837 to output a steady DC level (simulating 0 Hz by freezing its phase accumulator) and then switch to a sine wave output at a user-specified frequency. We’ll also demonstrate how to update the output frequency on the fly. The guide includes hardware wiring, SPI settings, an overview of the AD9837 command format and registers, the frequency tuning word calculation, and step-by-step examples in Arduino C code. All examples assume 3.3 V logic (which is compatible with both the RP2040 and AD9837) and use the Arduino SPI library for communication.

## Hardware Setup: RP2040 to AD9837 Wiring

Proper wiring is crucial for reliable SPI communication and waveform output. Connect the RP2040 board to the AD9837 as follows:

- **Power:** Connect the AD9837 **VCC** pin to the RP2040’s 3.3 V output and **GND** to common ground. (The AD9837 supports 2.3 V–5.5 V supply; using 3.3 V ensures logic level compatibility ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=,Signal%20Input)).)
- **SPI MOSI -> SDATA:** Connect the RP2040’s MOSI (Master-Out Slave-In) pin to the AD9837 **SDATA** pin. This carries the serial data from the microcontroller to the AD9837 ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=,OUT%20to%20Oscilloscope%20Signal%20Input)).
- **SPI SCLK -> SCLK:** Connect the RP2040’s SCK (serial clock) pin to the AD9837 **SCLK** pin. This clock synchronizes data bits on SDATA ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=,OUT%20to%20Oscilloscope%20Signal%20Input)).
- **Chip Select -> FSYNC:** Choose a free digital GPIO on the RP2040 for the AD9837 **FSYNC** (frame sync) pin. Connect that GPIO to FSYNC and configure it as a digital output in Arduino. FSYNC is active-low and acts as the chip-select to frame each 16-bit word transfer ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=7%20SCLK%20Serial%20Clock%20Input,output%20from%20the%20AD9837%20is)). When FSYNC is low, the AD9837 listens for incoming SPI clock and data; when FSYNC goes high, the 16-bit word is latched.
- **Master Clock (MCLK):** The AD9837 requires a **reference clock** to generate waveforms. Connect the AD9837 **MCLK** pin to a clock source. This could be an external oscillator or a microcontroller-generated clock. For example, you might use an RP2040 PWM output or PIO to generate a stable clock (1 MHz, 8 MHz, 16 MHz, etc., as needed). The output frequency of the DDS will be a fraction of this MCLK frequency ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=4%20DGND%20Digital%20Ground,is%20applied%20to%20this%20input)), so a higher MCLK allows higher and more precise output frequencies (the AD9837 supports up to 16 MHz MCLK on the B-grade device ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Digitally%20programmable%20frequency%20and%20phase,down%20option))). If your AD9837 module already includes a crystal oscillator, use that as the MCLK source per the module’s documentation.
- **Output (VOUT):** The AD9837’s analog output comes from the **VOUT** pin. This is where the waveform (sine, triangle, or square wave) is produced. No external load resistor is required on this pin because the AD9837 has an internal 200 Ω resistor to ground on-chip ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=9%20AGND%20Analog%20Ground,the%20exposed%20pad%20to%20ground)). You can connect VOUT to an oscilloscope or to downstream circuitry. For best results, tie the AD9837 **AGND** (analog ground) to the analog ground of your measurement or circuit (often the same as digital ground on simple setups) ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=,OUT%20to%20Oscilloscope%20Signal%20Input)).

**Power and signal integrity considerations:** Place a 0.1 µF decoupling capacitor close between the AD9837’s VCC and GND ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Pin%20No,regulator%20requires%20a%20decoupling%20capacitor)). Also connect a 100 nF capacitor from the **CAP/2.5V** pin to ground (if your board hasn’t already) to stabilize the AD9837’s internal 2.5 V regulator ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=be%20connected%20between%20VDD%20and,4%20DGND%20Digital%20Ground)). The **COMP** pin (DAC bias decoupling) should have the recommended capacitor per the datasheet (typically another 0.1 µF to ground) to ensure a clean analog output ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Pin%20No,board)). These capacitors help maintain stable voltage references for the DAC. All grounds (DGND and AGND) should be at the same potential to avoid noise. The AD9837’s output is a relatively low-amplitude signal (~0.6 V<sub>pp</sub> for sine waves ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=%2F,645V%3B)), centered around mid-supply) – if you need a larger amplitude or a bipolar signal (centered at 0 V), plan to use an amplifier or coupling network after VOUT.

## SPI Interface Configuration

The AD9837 communicates via a 3-wire SPI-compatible interface (SDATA, SCLK, FSYNC) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=The%20AD9837%20is%20written%20to,lead%20LFCSP_WD%20package)). Key SPI settings for the RP2040 (Arduino SPI library) are:

- **SPI Mode:** **Mode 2** (CPOL = 1, CPHA = 0). In Mode 2, the SCLK line idles high, and data is latched on the falling edge of SCLK ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=derived%20from%20a%20port%20line,the%20first%20eight%20bits%20are)) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=%E2%80%A2%20SCK%20idles%20high%20between,second%20eight%20bits%20are%20transferred)). This is required for the AD9837, which clocks data in on SCLK’s falling edges ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=6%20SDATA%20Serial%20Data%20Input,is%20applied%20to%20this%20input)). For example, in Arduino you would use `SPI.beginTransaction(SPISettings(clockFreq, MSBFIRST, SPI_MODE2));` or `SPI.setDataMode(SPI_MODE2);` before transmitting ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=digitalWrite)).
- **SPI Clock Frequency:** The AD9837 supports very high SPI clock rates (up to 40 MHz max) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=The%20AD9837%20is%20written%20to,lead%20LFCSP_WD%20package)). You can use a fast SPI clock (e.g. 1–10 MHz) to send commands quickly. In practice, even a few MHz is sufficient since frequency updates are not typically streaming continuously. We will use a moderate SPI clock in our code examples for reliability.
- **Data Order:** Most-significant bit first. The AD9837 expects 16-bit command words with the MSB (D15) sent first ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=When%20data%20is%20to%20be,FSYNC%20be%20taken%20high%20again)), which is Arduino’s default (MSBFIRST).
- **Frame Sync (FSYNC):** Remember to pull FSYNC low *before* sending each 16-bit word, and then pull it high *after* the word has been fully clocked out (16 bits). Toggling FSYNC frames each write and tells the AD9837 to latch the word on the rising edge of FSYNC ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=When%20data%20is%20to%20be,FSYNC%20be%20taken%20high%20again)). If you use Arduino’s `SPI.transfer16()`, it will send 16 bits in one call; you would typically do `digitalWrite(FSYNC, LOW)`, `SPI.transfer16(word)`, then `digitalWrite(FSYNC, HIGH)`.

The RP2040’s hardware SPI (in Arduino) will handle the timing of individual SCLK pulses. Just ensure that FSYNC is not brought HIGH until exactly 16 bits have been sent. (In our examples, we’ll manually control FSYNC around two 8-bit transfers or one 16-bit transfer.)

**Note:** The AD9837 is a write-only device; it does not send data back on MISO. So, you don’t need to connect MISO for this project. Also, if using multiple SPI devices on the same bus, be sure each has its own CS/FSYNC line and that only the intended device’s CS is low while transferring.

## AD9837 Command Format and Register Map

Understanding the AD9837’s registers and command word format is key to controlling it. All communications occur by writing 16-bit words to the device. The top two bits of each 16-bit word (D15 and D14) serve as the **address or control bits**, indicating which register is being updated ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%209,must%20be%20set)):

- If **D15:D14 = 00**, the word is a write to the **Control Register** ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=To%20inform%20the%20AD9837%20that,bits%20SIN%20ROM%20PHASE%20ACCUMULATOR)) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=D15%20D14%20D13%20to%20D0,BIT%20DAC%200)).
- If **D15:D14 = 01**, the word contains data for a **Frequency Register** (we’ll determine which one by other means).
- If **D15:D14 = 10**, the word contains data for a **Frequency Register** as well (the AD9837 has two frequency registers, FREQ0 and FREQ1, and this combination selects the second one) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%209,must%20be%20set)).
- If **D15:D14 = 11**, the word is a write to a **Phase Register** (the AD9837 has two 12-bit phase registers) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Writing%20to%20a%20Phase%20Register,D13%20D12%20D11%20to%20D0)).

So, effectively:
- **Control Register write:** Word = `0x0000 | [14-bit control data]`
- **Frequency 0 register write:** Word = `0x4000 | [14-bit frequency data]` (since 01 in D15:D14 is binary `01` which is 0x4000 when placed in the top bits of 16-bit word) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%209,must%20be%20set)).
- **Frequency 1 register write:** Word = `0x8000 | [14-bit frequency data]` (since 10 in D15:D14 is `10` binary which corresponds to 0x8000).
- **Phase register write:** Word = `0xC000 | [12-bit phase data]` (with an extra bit in D13 selecting phase register 0 or 1).

The AD9837 contains the following important registers:
- **Control Register (16 bits):** Configures output waveform type, enables/disables functions, and selects which frequency/phase registers are used. We’ll detail key bits below.
- **Frequency Registers (Freq0 & Freq1, 28 bits each):** Hold the frequency tuning words that set the output frequency.
- **Phase Registers (Phase0 & Phase1, 12 bits each):** Hold phase offset values (useful to phase-shift the output waveform).

Because SPI writes are 16 bits and the frequency registers are 28 bits wide, loading a frequency register requires *two* consecutive writes. The AD9837 internally concatenates two 14-bit writes into the 28-bit frequency word *when using the proper control bit settings*, as explained next.

### Control Register Bits Breakdown

When writing to the control register (D15:D14 = 00), the remaining 14 bits have the following important fields (refer to the AD9837 datasheet for a full list ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=D13%20B28%20D12%20HLB%20D11,FSEL%20D10%20PSEL%20D9)) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200))):

- **B28 (D13):** Controls how frequency writes are done.
  - B28 = 1: Enables **28-bit frequency writes**. The next two writes to a frequency register (with D15:D14 = 01 or 10) are loaded as a single 28-bit value (first write loads LSB 14 bits, second loads MSB 14 bits) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=To%20change%20the%20entire%20contents,0000%200000%20Control%20word%20write)). We will use this mode for simplicity.
  - B28 = 0: 14-bit writes mode. You can update just the lower 14 bits or upper 14 bits of a frequency register using the HLB bit (below). This is useful for fine or coarse tuning separately, but we won’t need it in this tutorial.
- **HLB (D12):** High/Low Byte control for frequency writes when B28=0. (Ignored when B28=1) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=users%20alternate%20between%20the%20two,see)).
- **FSEL (D11):** Frequency register select. Chooses which frequency register (FREQ0 or FREQ1) is used by the DDS for output ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%209,must%20be%20set)). FSEL = 0 uses FREQ0, FSEL = 1 uses FREQ1. You can preload two different frequencies and toggle this bit to switch the output frequency almost instantly.
- **PSEL (D10):** Phase register select. Chooses Phase0 or Phase1 for the output phase offset in a similar way (PSEL = 0 for Phase0, = 1 for Phase1).
- **RESET (D8):** **Reset bit**. When set to 1, this resets the internal phase accumulator to 0 and **holds it there**, essentially freezing the output at a midscale DC level ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200)). Reset = 0 releases the accumulator to run. (Important: The frequency and phase register contents are *not* cleared by this reset; it only affects the accumulator output state ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200)).)
- **SLEEP1 (D7):** Sleep control for internal clock. When SLEEP1 = 1, the internal MCLK (master clock) is disabled, so the DDS stops accumulating *but holds the output at its current value* ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Internal%20Clock%20Disabled%20When%20the,while%20SLEEP1%20was%20active%20are)). (We will prefer using RESET for a known 0 Hz output, since Sleep1 doesn’t guarantee the output is midscale – it just freezes whatever the last output was.)
- **SLEEP12 (D6):** Sleep control for DAC. When SLEEP12 = 1, the DAC is powered down (useful if you only want a clock output via MSB, or to save power) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2015,DAC%20can%20be%20powered%20down)). We will keep this 0 (DAC active).
- **OPBITEN (D5):** Output enable for the **MSB** (digital) output. This bit is used to route a digital clock/square wave to the VOUT pin instead of the analog sine/triangle output ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2016,By)). We want analog sine output, so OPBITEN = 0.
- **DIV2 (D3):** When using the MSB output (OPBITEN=1 for square wave), DIV2 divides the output frequency by 2 (i.e., outputs MSB/2) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2016,By)). Not used for sine output (we’ll set DIV2 = 0).
- **MODE (D1):** Selects waveform shape when using the DAC. MODE = 0 for **sine wave** (the default, via the sinusoidal lookup table), MODE = 1 for **triangle wave** output (bypasses the sine ROM) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2016,By)). We’ll use MODE = 0 for sine. (If OPBITEN=1, this bit has a different meaning, but we ignore that case.)

Other control register bits are either reserved (must be 0) or used in combinations for specific functions as described. For our purposes:
- **Initial Control Reg configuration:** We will set B28=1 (enable 28-bit freq writes), FSEL=0 (start with FREQ0), PSEL=0 (Phase0), RESET=1 (hold at midscale until we’re ready to output wave), SLEEP1=0, SLEEP12=0 (no sleeps), OPBITEN=0 (DAC output enabled), MODE=0 (sine wave). Putting those bits together yields a 16-bit control word. For example, one such configuration is `0x2100` in hex, which corresponds to B28=1 and RESET=1 with everything else 0 ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=WriteRegisterAD9837)).

## Frequency Tuning Word Calculation

The AD9837 uses **Direct Digital Synthesis (DDS)**: the output frequency is determined by a digital tuning word (in the 28-bit frequency register) and the master clock frequency. The relation is:

\[ \text{Output Frequency} = \dfrac{\text{Freq Register (28-bit)}}{2^{28}} \times \text{MCLK Frequency} \]

Solving for the frequency register value (the tuning word):

\[ \text{Freq Word} = \frac{\text{Desired Frequency}}{\text{MCLK Frequency}} \times 2^{28} \]

This value must be an integer (the fractional part is dropped). In other words, the 28-bit frequency word is a binary fraction of the MCLK. For example, if MCLK = 16 MHz and you want a 10 kHz output, the calculation would be:

- Fraction = 10 000 / 16 000 000 = 0.000625
- 28-bit word = 0.000625 × 2^28 ≈ 0.000625 × 268 435 456 ≈ 167 772 (in decimal)

In hex, 167772 is 0x028F5C (we’ll show how to split this into two parts next). The AD9837’s 28-bit resolution means you can fine-tune frequencies with very high precision (≈0.06 Hz resolution with 16 MHz MCLK ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=8,down%20option))).

**Note:** The maximum representable tuning word is 0xFFFFFFF (28 bits of 1), which would theoretically yield an output frequency just a hair below the MCLK frequency (effectively MCLK * (2^28 – 1)/2^28). In practice, the output frequency is limited to somewhat below MCLK/2 for sine waves to avoid signal distortion (Nyquist limit). The AD9837’s analog output bandwidth is limited; for instance, with a 16 MHz clock, you can generate up to a few MHz of output, but the sine wave amplitude will drop at higher frequencies ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=,635V)).

### Splitting the 28-bit Word

Once you compute the 28-bit frequency word, you need to split it into two 14-bit halves for writing to the AD9837. Let’s call the 28-bit value `freqWord`. You can obtain the lower 14 bits (LSB part) and upper 14 bits (MSB part) as follows in C/C++:

- `uint16_t lsb14 = freqWord & 0x3FFF;`  (0x3FFF = binary 0011 1111 1111 1111, mask for 14 bits)  
- `uint16_t msb14 = (freqWord >> 14) & 0x3FFF;`  (shifting right by 14 gets the top 14 bits, then mask)

Before sending these to the AD9837, you must also add the frequency register identifier to each 14-bit chunk. For example, to load **Frequency Register 0**:
- Set D15:D14 = 01 for both LSB and MSB words. In code, this means do `lsb14 |= 0x4000;` and `msb14 |= 0x4000;` ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=MSB%20%3D%20%28int%29%28%28calculated_freq_word%20%26%200xFFFC000%29,calculated_freq_word%20%26%200x3FFF)). Now `lsb14` and `msb14` are 16-bit words ready to send via SPI.
- Then send the LSB word first, followed by the MSB word (with B28=1 in the control register, the AD9837 will not update the output frequency until it has received both halves of the new word ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=To%20change%20the%20entire%20contents,0000%200000%20Control%20word%20write))).

If you were updating **Frequency Register 1** instead, you would use 0x8000 (binary 10 in D15:D14) as the prefix for both halves.

**Phase word calculation (optional):** Similarly, a phase offset (in radians) can be written as a 12-bit value in a phase register. The relation is PhaseWord = (desired_phase / 2π) × 2^12. For a phase of 0°, the word is 0. We won’t focus on phase control in this tutorial (we’ll use the default 0 phase).

## Initialization Sequence and 0 Hz (DC) Output

With the hardware wired and understanding of the registers, let’s walk through the procedure to initialize the AD9837 and produce a steady DC output (0 Hz):

1. **Begin SPI and Set FSYNC High:** In your Arduino `setup()`, call `SPI.begin()` to initialize the SPI bus. Configure the SPI mode and speed as described (Mode 2, etc.). Also configure the FSYNC pin as an output, and drive it HIGH to start (FSYNC idles high when no communication). For example: 
   ```cpp
   pinMode(FSYNC_PIN, OUTPUT);
   digitalWrite(FSYNC_PIN, HIGH);
   SPI.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE2)); // 2 MHz, adjust as needed
   ```
   (Alternatively, you can use `SPI.setDataMode(SPI_MODE2)` and related SPI calls.)
   
2. **Reset the AD9837 (software reset):** It’s recommended to reset the DDS on power-up ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200)). We do this by setting the RESET bit in the control register. Construct a control word with RESET=1, B28=1 (to prepare for frequency writes), and other bits as needed (as discussed in Control Register Bits). For example, `control = 0x2100` as described earlier. Send this control word via SPI:
   ```cpp
   writeRegister(0x2100);  // B28=1, RESET=1, sine wave, use FREQ0 & PHASE0
   ``` 
   Where `writeRegister(word)` is a helper function that pulls FSYNC low, transfers the 16-bit word, and then raises FSYNC (we’ll define it in code shortly). Setting RESET=1 ensures the phase accumulator is held in reset, which forces the DAC output to a constant midscale level (this yields a DC output voltage at VOUT) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200)). **At this point, the AD9837’s output is a steady DC voltage** (no waveform), because we’ve essentially told it to “freeze” the sine wave at 0 Hz.

3. **Load frequency register to 0 Hz:** Although after a reset the output is DC, it’s good practice to explicitly set the frequency register to 0 as well (especially if we plan to use the FREQ register method for 0 Hz). We can write 0x0000000 to FREQ0 in two halves. The 28-bit value for 0 Hz is 0. Split into two 14-bit halves: LSB = 0x0000, MSB = 0x0000. Add the FREQ0 identifier (0x4000) to each:
   ```cpp
   writeRegister(0x4000);  // FREQ0 LSB = 0
   writeRegister(0x4000);  // FREQ0 MSB = 0
   ```
   These two writes load FREQ0 with 0x0000000. Because we set B28=1 in the control register, the device knows to take these two consecutive writes as one 28-bit update ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=To%20change%20the%20entire%20contents,0000%200000%20Control%20word%20write)). (If B28 were 0, we’d have to manage the HLB bit and do it differently.)

4. **(Optional) Load phase register (Phase0):** If not using any phase offset, this can be skipped, as Phase0 defaults to 0. For completeness, you could write the phase register with 0 as well. D15:D14 for phase write is 11 (0xC000). For Phase0, D13 = 0. So a 16-bit word `0xC000` would set Phase0 = 0. For example:
   ```cpp
   writeRegister(0xC000);  // Phase0 = 0
   ```
   This step ensures the starting phase is 0°.

At this point, we have:
- Control reg: RESET=1 (holding output in midscale), B28=1, using FREQ0 and PHASE0.
- FREQ0 = 0 (0 Hz).
- Phase0 = 0.

The AD9837 is configured but **no sine wave is output yet** because the DDS is still in reset (the output is just a constant midscale voltage). This is our **steady 0 Hz initialization state**.

## Enabling the Sine Wave Output at a Specified Frequency

Now, suppose we want to start generating a sine wave of a given frequency (for example, 10 kHz). We have two ways to accomplish this:
- **Method A:** Write a new frequency word to the active frequency register and then clear the RESET bit to start generation.
- **Method B:** Preload the alternate frequency register and toggle the FSEL bit to switch to it, then clear RESET. (This method is useful for quick switching between two predetermined frequencies, e.g., between 0 Hz and some set frequency.)

We will demonstrate a simple approach using Method A, then discuss Method B for completeness.

### Setting a Specific Frequency (e.g., 10 kHz)

Let’s continue the initialization by configuring a 10 kHz output:

5. **Calculate the tuning word:** Using the formula above, if MCLK = 16 MHz and desired frequency = 10 kHz:
   \[
   \text{freqWord} = \frac{10000}{16000000} \times 2^{28} \approx 167772
   \] 
   In code, you might do:
   ```cpp
   uint32_t freqWord = (uint32_t)((10000.0 / 16000000.0) * 268435456.0);  // 2^28 = 268435456
   ```
   This calculation yields 167772. (You can also avoid floating point by doing the multiplication first in 64-bit then dividing by MCLK.)

6. **Split into 14-bit words:** 
   ```cpp
   uint16_t lsb = freqWord & 0x3FFF;           // lower 14 bits
   uint16_t msb = (freqWord >> 14) & 0x3FFF;   // upper 14 bits
   lsb |= 0x4000;  // add FREQ0 address bits (01 in D15:D14) ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=MSB%20%3D%20%28int%29%28%28calculated_freq_word%20%26%200xFFFC000%29,calculated_freq_word%20%26%200x3FFF))
   msb |= 0x4000;  // add FREQ0 address bits
   ```
   Now `lsb` and `msb` contain the properly formatted 16-bit words to load into FREQ0.

7. **Write the new frequency to FREQ0:** Send the LSB word first, then the MSB word:
   ```cpp
   writeRegister(lsb);
   writeRegister(msb);
   ```
   After these two writes, FREQ0 register holds the tuning word for ~10 kHz. (The output still hasn’t started because RESET is still 1; we’re essentially queuing up the frequency.)

8. **Clear RESET to start the waveform:** Now prepare a new control register word identical to the one in step 2 but with RESET = 0 (and FSEL still 0 to use FREQ0). In our example, that would be `0x2000` (since 0x2100 was with RESET bit, and clearing D8 gives 0x2000) ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=%2F%2FPower%20it%20back%20up%20%2F%2FAD9837Write,0x2002%29%3B%20%2F%2Ftriangle)). Write this control word:
   ```cpp
   writeRegister(0x2000);  // Clear RESET, B28=1 (keep), FSEL=0, sine mode
   ```
   Setting RESET=0 releases the phase accumulator. The AD9837 will now begin generating a sine wave at the frequency in FREQ0 (10 kHz in our case). According to the datasheet, the output will appear after at most 7–8 MCLK cycles from this point ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=AD9837%20section%29,applied%201%20Internal%20registers%20reset)) (which at 16 MHz is about 0.5 µs). In practice, the transition is almost instantaneous on a human time scale.

**You should now see a 10 kHz sine wave** at the AD9837’s VOUT pin. The amplitude will be around 0.6 V<sub>pp</sub> (approximately 0.3 V above and below the midscale voltage of ~0.3 V DC). 

*Optional:* If you wanted to output a triangle wave instead, you would set the MODE bit = 1 in the control register at this point (and still keep OPBITEN=0). Or for a square wave, set OPBITEN=1 and choose DIV2 as needed. But since our focus is sine waves, we left MODE=0.

### Dynamic Frequency Updates On Command

One advantage of DDS is the ability to change the frequency smoothly at runtime. To change the output frequency on the fly, you simply need to calculate a new tuning word and write it to the active frequency register (FREQ0 or FREQ1). The output frequency will update almost immediately once the 28-bit word is fully updated – no need to reset the device (in fact, do **not** set RESET for a frequency change, or you’ll momentarily disrupt the waveform).

Continuing our example, suppose we want to change from 10 kHz to 5 kHz without stopping the waveform:

1. **Calculate new freqWord:** For 5 kHz with 16 MHz MCLK:
   \[
   \text{freqWord}_{5k} = \frac{5000}{16000000} \times 2^{28} \approx 83886
   \] 
   (Half the previous word since frequency halved.)
2. **Split into lsb and msb 14-bit halves, add address bits:** (Same process as before.)
3. **Write LSB then MSB to FREQ0:** Use `writeRegister` again for the two halves.

Because we had B28=1 mode enabled, writing the two halves back-to-back will update FREQ0 in one operation with no intermediate glitch ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=To%20change%20the%20entire%20contents,0000%200000%20Control%20word%20write)). The AD9837 will start outputting 5 kHz as soon as the second half-word is latched. The phase accumulator will continue from its current phase seamlessly, now incrementing at a different rate. In other words, the frequency change is phase-continuous (no abrupt discontinuity in the waveform, just a change in frequency).

**Important:** Ensure that you send both halves in quick succession. If too much delay occurs between the LSB and MSB write, the device might latch the new word after the first half (14 bits) which would produce an incorrect frequency until the second half is received. In practice, if you call your `writeRegister` twice in a row, it will be fine. (The datasheet notes that if you do *continuous* writes to the same frequency register without two-in-a-row grouping, you could get intermediate updates; one strategy for frequency sweeping is to alternate between FREQ0 and FREQ1 registers so each complete word update is done on a register that isn’t currently outputting ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=,bit%20frequency)).)

### Switching Between 0 Hz (DC) and Active Waveform

The user’s scenario might involve toggling the output between a dormant state (DC output) and an active waveform. There are a couple of ways to accomplish this cleanly:

- **Using the RESET bit:** The simplest way to halt the waveform and return to a steady DC output is to set the RESET bit = 1 again. This resets the phase accumulator and holds it, forcing the output to midscale DC ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200)). When you want to resume the waveform, clear RESET = 0. However, note that when you re-enable, the phase restarts at 0, so the sine wave begins anew at the reference phase.
- **Using dual frequency registers (FSEL toggle):** Another approach is to dedicate one frequency register to “0 Hz”. For example, you can keep FREQ0 = 0 and have FREQ1 = some frequency. By toggling the FSEL bit in the control register, you can switch the output between FREQ0 (which yields 0 Hz) and FREQ1 (the waveform) almost instantly ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%209,must%20be%20set)). The advantage is that you don’t disturb the phase accumulator’s running state except for the change in increment. One caveat: switching to 0 Hz via FSEL will freeze the phase accumulator at its current phase (because now the increment is 0). This means the output will hold at whatever voltage it was at the moment of switching (which might **not** be midscale unless the phase happened to be 0 or π at that time). If you require the output to go to a known DC level (midscale) when “off,” then using the RESET bit is preferred.

In summary, for a guaranteed midscale DC output to simulate 0 Hz, use the RESET bit. For a phase-continuous switch that just freezes the waveform wherever it is (perhaps acceptable in some applications), you could use Sleep1 or switch to a 0 Hz frequency register. In our code example below, we’ll use RESET to stop the output, as it provides a consistent known output level ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200)).

## Complete Arduino Example Code

Below is an example that incorporates the above steps. It initializes the AD9837, outputs 0 Hz (DC), then after 2 seconds starts a 10 kHz sine wave, and later demonstrates changing the frequency to 5 kHz. It also toggles the output between active and DC using RESET for demonstration. This example uses an RP2040 (e.g., Feather RP2040 or Raspberry Pi Pico with the Arduino core) – adjust pin numbers as needed for your specific board (the SPI pins and one CS pin).

```cpp
#include <SPI.h>

// Pin definitions (update these for your hardware setup)
const int FSYNC_PIN = 5;       // GP5 as FSYNC (chip select for AD9837)
const int MCLK_PIN = 9;        // Example: GP9 used to output MCLK (if using PWM for clock) 
                               // Alternatively, use an external oscillator and ignore this.

void writeRegister(uint16_t value) {
  digitalWrite(FSYNC_PIN, LOW);
  SPI.transfer16(value);      // Send 16-bit value, MSB first
  digitalWrite(FSYNC_PIN, HIGH);
}

void setup() {
  // Initialize serial monitor (optional, for debug)
  Serial.begin(115200);
  
  // Setup FSYNC pin
  pinMode(FSYNC_PIN, OUTPUT);
  digitalWrite(FSYNC_PIN, HIGH);
  
  // (Optional) Setup MCLK output if using microcontroller to generate master clock
  // Here we use a PWM on GP9 to generate ~1 MHz clock for simplicity.
  // For higher frequency, consider using RP2040 PIO or a crystal oscillator.
  pinMode(MCLK_PIN, OUTPUT);
  // Using a simplistic approach: toggle GP9 in a timer or use tone() if available
  // (RP2040 Arduino supports tone() on any pin; tone(pin, frequency) generates a square wave)
  tone(MCLK_PIN, 1000000);  // 1 MHz clock output on GP9 as MCLK (adjust freq as needed)
  
  // Initialize SPI in Mode 2
  SPI.begin();
  SPI.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE2));
  
  // Reset and configure AD9837
  writeRegister(0x2100);  // Control: B28=1, RESET=1, FREQ0, Phase0, sine wave ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=WriteRegisterAD9837))
  
  writeRegister(0x4000);  // FREQ0 LSB = 0 (0 Hz) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2010,14%20MSBs%20%3D%200x3FFF))
  writeRegister(0x4000);  // FREQ0 MSB = 0 (complete the 28-bit write) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=HLB%20,between%20the%20two%20frequency%20registers))
  writeRegister(0xC000);  // PHASE0 = 0 (12-bit phase, D15:D14 = 11) – optional
  
  // (At this point, output is DC because RESET=1)
  Serial.println("AD9837 initialized in reset (0 Hz DC output)");
  delay(2000);
  
  // Set a 10 kHz frequency in FREQ0
  float desiredFreq = 10000.0;      // 10 kHz
  float mclkFreq    = 1000000.0;    // 1 MHz MCLK in this example
  uint32_t freqWord = (uint32_t)((desiredFreq / mclkFreq) * 268435456.0);  // calc 28-bit word
  
  uint16_t lsb = freqWord & 0x3FFF;
  uint16_t msb = (freqWord >> 14) & 0x3FFF;
  lsb |= 0x4000;  // add freq0 address bits ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=MSB%20%3D%20%28int%29%28%28calculated_freq_word%20%26%200xFFFC000%29,calculated_freq_word%20%26%200x3FFF))
  msb |= 0x4000;
  
  writeRegister(lsb);  // write lower 14 bits of frequency
  writeRegister(msb);  // write upper 14 bits of frequency (frequency update occurs here)
  
  // Take AD9837 out of reset to start the sine wave
  writeRegister(0x2000);  // Control: B28=1, RESET=0, output enabled ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=%2F%2FPower%20it%20back%20up%20%2F%2FAD9837Write,0x2002%29%3B%20%2F%2Ftriangle))
  Serial.println("Outputting 10 kHz sine wave");
  
  delay(5000);
  
  // Dynamically change frequency to 5 kHz
  desiredFreq = 5000.0;  // new frequency
  freqWord = (uint32_t)((desiredFreq / mclkFreq) * 268435456.0);
  lsb = freqWord & 0x3FFF;
  msb = (freqWord >> 14) & 0x3FFF;
  lsb |= 0x4000;
  msb |= 0x4000;
  
  writeRegister(lsb);
  writeRegister(msb);
  Serial.println("Frequency changed to 5 kHz (on the fly)");
  
  delay(5000);
  
  // Demonstrate switching back to DC (0 Hz) by using RESET
  writeRegister(0x2100);  // Control: B28=1, RESET=1 (stop output, back to midscale DC)
  Serial.println("Output reset to 0 Hz (DC)");
  
  delay(3000);
  
  // Resume output at 5 kHz by clearing RESET again
  writeRegister(0x2000);  // Control: B28=1, RESET=0 (resume sine output)
  Serial.println("Resume 5 kHz sine output");
}

void loop() {
  // In a real application, you could listen for user commands (e.g., Serial input)
  // to set new frequencies or toggle output on/off using similar code as above.
}
```

In this code, `writeRegister()` is a helper that wraps the SPI transfers with FSYNC control. We used `SPI.transfer16` for convenience, which sends two bytes in succession. The code uses a 1 MHz MCLK (via `tone()` on the RP2040) for demonstration — you can adjust `mclkFreq` and the `tone()` frequency to match your actual MCLK. With 1 MHz MCLK, a 10 kHz output requires a relatively small tuning word (which we computed accordingly). If you use a higher MCLK (like 16 MHz), make sure to update `mclkFreq` in the calculation.

After uploading this code, you can monitor the serial output (optional) and, more importantly, measure the AD9837’s VOUT pin with an oscilloscope or frequency counter:
- Initially, you should see roughly a flat line (DC) at about half the supply voltage.
- After 2 seconds, a 10 kHz sine wave starts. 
- Five seconds later, it shifts to 5 kHz smoothly.
- Then it turns off (DC mid-level) for 3 seconds.
- Finally, it resumes 5 kHz output.

All these without any hardware changes – purely by SPI commands to the AD9837.

## Additional Considerations and Datasheet Tips

- **Timing:** As noted, when coming out of reset (or sleep), the output takes a few MCLK cycles to reflect new data ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=AD9837%20section%29,applied%201%20Internal%20registers%20reset)). Similarly, when changing frequency, the new frequency is effective immediately after the second 14-bit word is latched (no significant extra delay). The AD9837 is designed for dynamic frequency switching and even frequency sweeping (the datasheet provides a flowchart and recommends using both frequency registers to avoid glitches during continuous updates ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=,bit%20frequency))).
- **Amplitude and Loading:** The AD9837’s DAC output is only ~0.6 V<sub>p-p</sub> into a high impedance load ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=%2F,645V%3B)). If you connect a heavy load, it will droop since the output impedance is about 200 Ω. For testing, use an oscilloscope or a buffer amplifier. If driving a load, consider a voltage follower op amp or an amplifier stage.
- **Waveform Shape:** We configured for sinusoidal output. If you need a square wave output, you could set OPBITEN=1 and DIV2 as needed (the square wave comes from the MSB of the DDS, which is a 50% duty cycle square at the frequency or half-frequency depending on DIV2 ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2016,By))). For a triangle wave, set MODE=1 (with OPBITEN=0) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2016,By)). These can be done by adjusting the control register writes.
- **Using FREQ1 and Phase1:** This tutorial stuck to FREQ0 and Phase0. You could preload FREQ1 with another frequency (and even Phase1 with a different phase) and then use `FSEL` or `PSEL` bits to switch frequencies or phase instantly without rewriting the tuning words. For example, for quick toggling between two preset frequencies, write both FREQ0 and FREQ1 during initialization (with RESET=1), then when running, flip FSEL in the control register to swap output frequency ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%209,must%20be%20set)). This is faster than writing 28 bits over SPI if you need very rapid toggling.
- **Power-down modes:** If you want to power down the AD9837 to save power (for instance, if the waveform is not needed for long periods), you can use the SLEEP12 bit to power down the DAC, and/or SLEEP1 to stop the clock, as shown in the datasheet ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=SLEEP%20FUNCTION%20Sections%20of%20the,0%201%20DAC%20powered%20down)) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=Table%2015,MSB%20of%20the%20DAC%20data)). Another option is simply removing RESET (which doesn’t save much power but stops output). Typically the chip only draws around 8.5 mW, so power saving isn’t critical unless you are on a tight battery budget.
- **Latency when changing settings:** If you change the output mode (sine/triangle or enabling the square wave mode), refer to the datasheet for any pipeline delays. Frequency and phase changes are pipelined but effectively immediate in output after a few clock cycles.

By following this guide, you should be able to reliably control the AD9837 DDS chip from your RP2040 microcontroller, generating waveforms at will. Always double-check the AD9837 datasheet for deeper information – especially **Analog Devices Application Notes** AN-1070 and AN-1044 which cover programming similar DDS chips (AD9833/AD9834) and frequency sweep techniques, respectively, which also apply to AD9837. Happy waveform generating!

**Sources:**

- Analog Devices, *AD9837 Datasheet* ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=FEATURES%20Digitally%20programmable%20frequency%20and,temperature%20range%3A%20%E2%88%9240%C2%B0C%20to%20%2B125%C2%B0C)) ([AD9837 (Rev. A)](https://www.farnell.com/datasheets/2149433.pdf#:~:text=RESET%20FUNCTION%20The%20reset%20function,bit%20is%20set%20to%200)) – for device specifications, register definitions, and timing information.
- DFRobot, *AD9837 DDS Module Wiki* – for pinouts and example usage ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=,OUT%20to%20Oscilloscope%20Signal%20Input)) ([SKU_DFR0973_AD9837_DDS_Waveform_Generator-DFRobot](https://wiki.dfrobot.com/SKU_DFR0973_AD9837_DDS_Waveform_Generator#:~:text=%2F,645V%3B)).
- Eldruin’s Tech Blog, *AD9833/AD9837 in Rust* – confirming interface similarity and usage notes ([AD9833/AD9837 Waveform Generator / DDS Driver in Rust | Eldruin's blog](https://blog.eldruin.com/ad983x-waveform-generator-dds-driver-in-rust/#:~:text=The%20AD9833%20and%20AD9837%20are,004%20Hz%20resolution)) ([AD9833/AD9837 Waveform Generator / DDS Driver in Rust | Eldruin's blog](https://blog.eldruin.com/ad983x-waveform-generator-dds-driver-in-rust/#:~:text=allowing%20easy%20tuning,004%20Hz%20resolution)).
- Example code and notes from community projects interfacing AD9837 (Arduino forum, Sinneb’s blog) – for practical tips on SPI mode and initialization ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=digitalWrite)) ([SPI control of AD9833 · sinneb](https://sinneb.github.io/p562/#:~:text=WriteRegisterAD9837)).